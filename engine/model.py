# Ultralytics YOLO ğŸš€, AGPL-3.0 license

import inspect  # ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«é–¢ã™ã‚‹æƒ…å ±ã‚’å–å¾—ã™ã‚‹ãŸã‚ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
from pathlib import Path  # ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦æ‰±ã†ãŸã‚ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
from typing import List, Union  # å‹ãƒ’ãƒ³ãƒˆã§ä½¿ç”¨ã™ã‚‹ãŸã‚ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

import numpy as np  # æ•°å€¤è¨ˆç®—ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
import torch  # PyTorchæ·±å±¤å­¦ç¿’ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
from PIL import Image  # ç”»åƒå‡¦ç†ãƒ©ã‚¤ãƒ–ãƒ©ãƒª

from cfg import TASK2DATA, get_cfg, get_save_dir  # è¨­å®šé–¢é€£ã®é–¢æ•°ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from .results import Results  # ãƒ¢ãƒ‡ãƒ«ã®å‡ºåŠ›çµæœã‚’æ ¼ç´ã™ã‚‹ã‚¯ãƒ©ã‚¹ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from hub import HUB_WEB_ROOT, HUBTrainingSession  # Ultralytics HUBã¨ã®é€£æºã«é–¢ã™ã‚‹ã‚¯ãƒ©ã‚¹ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from nn.tasks import attempt_load_one_weight, guess_model_task, nn, yaml_model_load  # ãƒ¢ãƒ‡ãƒ«ã®ãƒ­ãƒ¼ãƒ‰ã‚„ã‚¿ã‚¹ã‚¯ã®æ¨æ¸¬ã«é–¢ã™ã‚‹é–¢æ•°ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from utils import (  # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    ARGV,  # ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°
    ASSETS,  # ã‚¢ã‚»ãƒƒãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹
    DEFAULT_CFG_DICT,  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¨­å®šè¾æ›¸
    LOGGER,  # ãƒ­ã‚¬ãƒ¼
    RANK,  # ãƒ—ãƒ­ã‚»ã‚¹ãƒ©ãƒ³ã‚¯ï¼ˆåˆ†æ•£å­¦ç¿’ç”¨ï¼‰
    SETTINGS,  # è¨­å®š
    callbacks,  # ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
    checks,  # ãƒã‚§ãƒƒã‚¯é–¢æ•°
    emojis,  # çµµæ–‡å­—
    yaml_load,  # YAMLãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ­ãƒ¼ãƒ‰é–¢æ•°
)


class Model(nn.Module):  # PyTorchã®nn.Moduleã‚’ç¶™æ‰¿ã—ãŸModelã‚¯ãƒ©ã‚¹
    # YOLOãƒ¢ãƒ‡ãƒ«ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®åŸºæœ¬ã‚¯ãƒ©ã‚¹ã€‚ç•°ãªã‚‹ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—é–“ã§APIã‚’çµ±ä¸€ã—ã¾ã™ã€‚
    # ã“ã®ã‚¯ãƒ©ã‚¹ã¯ã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã€æ¤œè¨¼ã€äºˆæ¸¬ã€ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã€ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãªã©ã€YOLOãƒ¢ãƒ‡ãƒ«ã«é–¢é€£ã™ã‚‹ã•ã¾ã–ã¾ãªæ“ä½œã®ãŸã‚ã®å…±é€šã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚
    # ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã€Ultralytics HUBã€ã¾ãŸã¯Triton Serverã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸã‚‚ã®ã‚’å«ã‚€ã€ã•ã¾ã–ã¾ãªã‚¿ã‚¤ãƒ—ã®ãƒ¢ãƒ‡ãƒ«ã‚’å‡¦ç†ã—ã¾ã™ã€‚
    #
    # å±æ€§:
    #     callbacks (Dict): ãƒ¢ãƒ‡ãƒ«æ“ä½œä¸­ã®ã•ã¾ã–ã¾ãªã‚¤ãƒ™ãƒ³ãƒˆã«å¯¾ã™ã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã®è¾æ›¸ã€‚
    #     predictor (BasePredictor): äºˆæ¸¬ã‚’è¡Œã†ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹predictorã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚
    #     model (nn.Module): åŸºç›¤ã¨ãªã‚‹PyTorchãƒ¢ãƒ‡ãƒ«ã€‚
    #     trainer (BaseTrainer): ãƒ¢ãƒ‡ãƒ«ã®ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã«ä½¿ç”¨ã•ã‚Œã‚‹trainerã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚
    #     ckpt (Dict): ãƒ¢ãƒ‡ãƒ«ãŒ*.ptãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå ´åˆã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã€‚
    #     cfg (str): ãƒ¢ãƒ‡ãƒ«ãŒ*.yamlãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå ´åˆã®è¨­å®šã€‚
    #     ckpt_path (str): ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã€‚
    #     overrides (Dict): ãƒ¢ãƒ‡ãƒ«è¨­å®šã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã®è¾æ›¸ã€‚
    #     metrics (Dict): æœ€æ–°ã®ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°/æ¤œè¨¼ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã€‚
    #     session (HUBTrainingSession): Ultralytics HUBã‚»ãƒƒã‚·ãƒ§ãƒ³ï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰ã€‚
    #     task (str): ãƒ¢ãƒ‡ãƒ«ãŒå¯¾è±¡ã¨ã™ã‚‹ã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒ—ã€‚
    #     model_name (str): ãƒ¢ãƒ‡ãƒ«ã®åå‰ã€‚
    #
    # ãƒ¡ã‚½ãƒƒãƒ‰:
    #     __call__: predictãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã€ãƒ¢ãƒ‡ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å‘¼ã³å‡ºã—å¯èƒ½ã«ã—ã¾ã™ã€‚
    #     _new: è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã«åŸºã¥ã„ã¦æ–°ã—ã„ãƒ¢ãƒ‡ãƒ«ã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚
    #     _load: ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚
    #     _check_is_pytorch_model: ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚
    #     reset_weights: ãƒ¢ãƒ‡ãƒ«ã®é‡ã¿ã‚’åˆæœŸçŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚
    #     load: æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ã®é‡ã¿ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚
    #     save: ãƒ¢ãƒ‡ãƒ«ã®ç¾åœ¨ã®çŠ¶æ…‹ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ã—ã¾ã™ã€‚
    #     info: ãƒ¢ãƒ‡ãƒ«ã«é–¢ã™ã‚‹æƒ…å ±ã‚’ãƒ­ã‚°ã¾ãŸã¯è¿”ã—ã¾ã™ã€‚
    #     fuse: æœ€é©åŒ–ã•ã‚ŒãŸæ¨è«–ã®ãŸã‚ã«Conv2dãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨BatchNorm2dãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’èåˆã—ã¾ã™ã€‚
    #     predict: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ¤œå‡ºäºˆæ¸¬ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
    #     track: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¿½è·¡ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
    #     val: ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã§ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œè¨¼ã—ã¾ã™ã€‚
    #     benchmark: ã•ã¾ã–ã¾ãªã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå½¢å¼ã§ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã—ã¾ã™ã€‚
    #     export: ãƒ¢ãƒ‡ãƒ«ã‚’ã•ã¾ã–ã¾ãªå½¢å¼ã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚
    #     train: ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã§ãƒ¢ãƒ‡ãƒ«ã‚’ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã—ã¾ã™ã€‚
    #     tune: ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
    #     _apply: ãƒ¢ãƒ‡ãƒ«ã®ãƒ†ãƒ³ã‚½ãƒ«ã«é–¢æ•°ã‚’é©ç”¨ã—ã¾ã™ã€‚
    #     add_callback: ã‚¤ãƒ™ãƒ³ãƒˆã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’è¿½åŠ ã—ã¾ã™ã€‚
    #     clear_callback: ã‚¤ãƒ™ãƒ³ãƒˆã®ã™ã¹ã¦ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã€‚
    #     reset_callbacks: ã™ã¹ã¦ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé–¢æ•°ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚
    #
    # ä¾‹:
    #     >>> from ultralytics import YOLO
    #     >>> model = YOLO("yolo11n.pt")
    #     >>> results = model.predict("image.jpg")
    #     >>> model.train(data="coco8.yaml", epochs=3)
    #     >>> metrics = model.val()
    #     >>> model.export(format="onnx")

    def __init__(
        self,
        model: Union[str, Path] = "yolo11n.pt",  # ãƒ¢ãƒ‡ãƒ«ã®ãƒ‘ã‚¹ã¾ãŸã¯åå‰ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯"yolo11n.pt"
        task: str = None,  # ã‚¿ã‚¹ã‚¯ã®ç¨®é¡ã€‚Noneã®å ´åˆã¯è‡ªå‹•çš„ã«æ¨æ¸¬ã•ã‚Œã‚‹
        verbose: bool = False,  # è©³ç´°ãªãƒ­ã‚°ã‚’å‡ºåŠ›ã™ã‚‹ã‹ã©ã†ã‹ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯False
    ) -> None:
        # YOLOãƒ¢ãƒ‡ãƒ«ã‚¯ãƒ©ã‚¹ã®æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚
        # ã“ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€æä¾›ã•ã‚ŒãŸãƒ¢ãƒ‡ãƒ«ãƒ‘ã‚¹ã¾ãŸã¯åå‰ã«åŸºã¥ã„ã¦ãƒ¢ãƒ‡ãƒ«ã‚’è¨­å®šã—ã¾ã™ã€‚
        # ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã€Ultralytics HUBãƒ¢ãƒ‡ãƒ«ã€Triton Serverãƒ¢ãƒ‡ãƒ«ãªã©ã€ã•ã¾ã–ã¾ãªã‚¿ã‚¤ãƒ—ã®ãƒ¢ãƒ‡ãƒ«ã‚½ãƒ¼ã‚¹ã‚’å‡¦ç†ã—ã¾ã™ã€‚
        # ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ¢ãƒ‡ãƒ«ã®ã„ãã¤ã‹ã®é‡è¦ãªå±æ€§ã‚’åˆæœŸåŒ–ã—ã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã€äºˆæ¸¬ã€ã¾ãŸã¯ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãªã©ã®æ“ä½œã®æº–å‚™ã‚’ã—ã¾ã™ã€‚
        #
        # å¼•æ•°:
        #     model (Union[str, Path]): ãƒ­ãƒ¼ãƒ‰ã¾ãŸã¯ä½œæˆã™ã‚‹ãƒ¢ãƒ‡ãƒ«ã®ãƒ‘ã‚¹ã¾ãŸã¯åå‰ã€‚
        #         ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã€Ultralytics HUBã‹ã‚‰ã®ãƒ¢ãƒ‡ãƒ«åã€ã¾ãŸã¯Triton Serverãƒ¢ãƒ‡ãƒ«ã‚’æŒ‡å®šã§ãã¾ã™ã€‚
        #     task (str | None): YOLOãƒ¢ãƒ‡ãƒ«ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã€‚ãã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’æŒ‡å®šã—ã¾ã™ã€‚
        #     verbose (bool): Trueã®å ´åˆã€ãƒ¢ãƒ‡ãƒ«ã®åˆæœŸåŒ–ãŠã‚ˆã³å¾Œç¶šã®æ“ä½œä¸­ã«è©³ç´°ãªå‡ºåŠ›ã‚’æœ‰åŠ¹ã«ã—ã¾ã™ã€‚
        #
        # ä¾‹å¤–:
        #     FileNotFoundError: æŒ‡å®šã•ã‚ŒãŸãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„ã‹ã€ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„å ´åˆã€‚
        #     ValueError: ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯è¨­å®šãŒç„¡åŠ¹ã¾ãŸã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆã€‚
        #     ImportError: ç‰¹å®šã®ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—ï¼ˆHUB SDKãªã©ï¼‰ã«å¿…è¦ãªä¾å­˜é–¢ä¿‚ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ãªã„å ´åˆã€‚
        #
        # ä¾‹:
        #     >>> model = Model("yolo11n.pt")
        #     >>> model = Model("path/to/model.yaml", task="detect")
        #     >>> model = Model("hub_model", verbose=True)
        super().__init__()  # è¦ªã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å‘¼ã³å‡ºã™
        self.callbacks = callbacks.get_default_callbacks()  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’å–å¾—
        self.predictor = None  # å†åˆ©ç”¨å¯èƒ½ãªpredictor
        self.model = None  # ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        self.trainer = None  # trainerã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        self.ckpt = None  # *.ptã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã—ãŸå ´åˆã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆ
        self.cfg = None  # *.yamlã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã—ãŸå ´åˆã®è¨­å®š
        self.ckpt_path = None  # ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
        self.overrides = {}  # trainerã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸Šæ›¸ã
        self.metrics = None  # æ¤œè¨¼/ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ¡ãƒˆãƒªã‚¯ã‚¹
        self.session = None  # HUBã‚»ãƒƒã‚·ãƒ§ãƒ³
        self.task = task  # ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—
        model = str(model).strip()  # ãƒ¢ãƒ‡ãƒ«ã®ãƒ‘ã‚¹ã‚’æ–‡å­—åˆ—ã«å¤‰æ›ã—ã€å‰å¾Œã®ç©ºç™½ã‚’å‰Šé™¤

        # Load or create new YOLO model
        if Path(model).suffix in {".yaml", ".yml"}:  # ãƒ¢ãƒ‡ãƒ«ã®ãƒ‘ã‚¹ãŒYAMLãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ
            self._new(model, task=task, verbose=verbose)  # æ–°ã—ã„ãƒ¢ãƒ‡ãƒ«ã‚’åˆæœŸåŒ–
        else:  # ãƒ¢ãƒ‡ãƒ«ã®ãƒ‘ã‚¹ãŒYAMLãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯ãªã„å ´åˆ
            self._load(model, task=task)  # ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰

    def __call__(
        self,
        source: Union[str, Path, int, Image.Image, list, tuple, np.ndarray, torch.Tensor] = None,  # å…¥åŠ›ã‚½ãƒ¼ã‚¹ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã€URLã€PILã‚¤ãƒ¡ãƒ¼ã‚¸ã€numpyé…åˆ—ãªã©
        stream: bool = False,  # ã‚¹ãƒˆãƒªãƒ¼ãƒ å…¥åŠ›ã‚’å‡¦ç†ã™ã‚‹ã‹ã©ã†ã‹ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯False
        **kwargs,  # ãã®ä»–ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°
    ) -> list:
        # predictãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã€‚ãƒ¢ãƒ‡ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å‘¼ã³å‡ºã—å¯èƒ½ã«ã—ã¦äºˆæ¸¬ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
        # ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å¿…è¦ãªå¼•æ•°ã§ãƒ¢ãƒ‡ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç›´æ¥å‘¼ã³å‡ºã™ã“ã¨ã§ã€äºˆæ¸¬ãƒ—ãƒ­ã‚»ã‚¹ã‚’ç°¡ç´ åŒ–ã—ã¾ã™ã€‚
        #
        # å¼•æ•°:
        #     source (str | Path | int | PIL.Image | np.ndarray | torch.Tensor | List | Tuple): äºˆæ¸¬ã‚’è¡Œã†ç”»åƒã®ã‚½ãƒ¼ã‚¹ã€‚
        #         ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã€URLã€PILã‚¤ãƒ¡ãƒ¼ã‚¸ã€numpyé…åˆ—ã€PyTorchãƒ†ãƒ³ã‚½ãƒ«ã€ã¾ãŸã¯ã“ã‚Œã‚‰ã®ãƒªã‚¹ãƒˆ/ã‚¿ãƒ—ãƒ«ã‚’æŒ‡å®šã§ãã¾ã™ã€‚
        #     stream (bool): Trueã®å ´åˆã€å…¥åŠ›ã‚½ãƒ¼ã‚¹ã‚’äºˆæ¸¬ç”¨ã®é€£ç¶šã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚
        #     **kwargs (Any): äºˆæ¸¬ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ§‹æˆã™ã‚‹ãŸã‚ã®è¿½åŠ ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã€‚
        #
        # æˆ»ã‚Šå€¤:
        #     (List[ultralytics.engine.results.Results]): äºˆæ¸¬çµæœã®ãƒªã‚¹ãƒˆã€‚å„çµæœã¯Resultsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚«ãƒ—ã‚»ãƒ«åŒ–ã•ã‚Œã¾ã™ã€‚
        #
        # ä¾‹:
        #     >>> model = YOLO("yolo11n.pt")
        #     >>> results = model("https://ultralytics.com/images/bus.jpg")
        #     >>> for r in results:
        #     ...     print(f"Detected {len(r)} objects in image")
        return self.predict(source, stream, **kwargs)  # predictãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™

    def _new(self, cfg: str, task=None, model=None, verbose=False) -> None:
        # æ–°ã—ã„ãƒ¢ãƒ‡ãƒ«ã‚’åˆæœŸåŒ–ã—ã€ãƒ¢ãƒ‡ãƒ«å®šç¾©ã‹ã‚‰ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã‚’æ¨æ¸¬ã—ã¾ã™ã€‚
        # ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æä¾›ã•ã‚ŒãŸè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã«åŸºã¥ã„ã¦æ–°ã—ã„ãƒ¢ãƒ‡ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚
        # ãƒ¢ãƒ‡ãƒ«è¨­å®šã‚’ãƒ­ãƒ¼ãƒ‰ã—ã€ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯æ¨æ¸¬ã—ã€ã‚¿ã‚¹ã‚¯ãƒãƒƒãƒ—ã‹ã‚‰é©åˆ‡ãªã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ã—ã¦ãƒ¢ãƒ‡ãƒ«ã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚
        #
        # å¼•æ•°:
        #     cfg (str): YAMLå½¢å¼ã®ãƒ¢ãƒ‡ãƒ«è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã€‚
        #     task (str | None): ãƒ¢ãƒ‡ãƒ«ã®ç‰¹å®šã®ã‚¿ã‚¹ã‚¯ã€‚Noneã®å ´åˆã€è¨­å®šã‹ã‚‰æ¨æ¸¬ã•ã‚Œã¾ã™ã€‚
        #     model (torch.nn.Module | None): ã‚«ã‚¹ã‚¿ãƒ ãƒ¢ãƒ‡ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€‚æä¾›ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€æ–°ã—ã„ãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆã™ã‚‹ä»£ã‚ã‚Šã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
        #     verbose (bool): Trueã®å ´åˆã€ãƒ­ãƒ¼ãƒ‰ä¸­ã«ãƒ¢ãƒ‡ãƒ«æƒ…å ±ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
        #
        # ä¾‹å¤–:
        #     ValueError: è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒç„¡åŠ¹ã§ã‚ã‚‹ã‹ã€ã‚¿ã‚¹ã‚¯ã‚’æ¨æ¸¬ã§ããªã„å ´åˆã€‚
        #     ImportError: æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã«å¿…è¦ãªä¾å­˜é–¢ä¿‚ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ãªã„å ´åˆã€‚
        #
        # ä¾‹:
        #     >>> model = Model()
        #     >>> model._new("yolov8n.yaml", task="detect", verbose=True)
        cfg_dict = yaml_model_load(cfg)  # YAMLãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è¨­å®šã‚’ãƒ­ãƒ¼ãƒ‰
        self.cfg = cfg  # è¨­å®šã‚’ä¿å­˜
        self.task = task or guess_model_task(cfg_dict)  # ã‚¿ã‚¹ã‚¯ã‚’æ¨æ¸¬
        self.model = (model or self._smart_load("model"))(cfg_dict, verbose=verbose and RANK == -1)  # ãƒ¢ãƒ‡ãƒ«ã‚’æ§‹ç¯‰
        self.overrides["model"] = self.cfg  # ä¸Šæ›¸ãè¨­å®šã‚’æ›´æ–°
        self.overrides["task"] = self.task  # ä¸Šæ›¸ãè¨­å®šã‚’æ›´æ–°

        # Below added to allow export from YAMLs
        self.model.args = {**DEFAULT_CFG_DICT, **self.overrides}  # combine default and model args (prefer model args)
        self.model.task = self.task  # ãƒ¢ãƒ‡ãƒ«ã®ã‚¿ã‚¹ã‚¯ã‚’è¨­å®š
        self.model_name = cfg  # ãƒ¢ãƒ‡ãƒ«åã‚’è¨­å®š

    def _load(self, weights: str, task=None) -> None:
        # ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‹ã€é‡ã¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰åˆæœŸåŒ–ã—ã¾ã™ã€‚
        # ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€.ptãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ä»–ã®é‡ã¿ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã‹ã‚‰ã®ãƒ¢ãƒ‡ãƒ«ã®ãƒ­ãƒ¼ãƒ‰ã‚’å‡¦ç†ã—ã¾ã™ã€‚
        # ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸé‡ã¿ã«åŸºã¥ã„ã¦ã€ãƒ¢ãƒ‡ãƒ«ã€ã‚¿ã‚¹ã‚¯ã€ãŠã‚ˆã³é–¢é€£ã™ã‚‹å±æ€§ã‚’è¨­å®šã—ã¾ã™ã€‚
        #
        # å¼•æ•°:
        #     weights (str): ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ã®é‡ã¿ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã€‚
        #     task (str | None): ãƒ¢ãƒ‡ãƒ«ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸã‚¿ã‚¹ã‚¯ã€‚Noneã®å ´åˆã€ãƒ¢ãƒ‡ãƒ«ã‹ã‚‰æ¨æ¸¬ã•ã‚Œã¾ã™ã€‚
        #
        # ä¾‹å¤–:
        #     FileNotFoundError: æŒ‡å®šã•ã‚ŒãŸé‡ã¿ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„ã‹ã€ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„å ´åˆã€‚
        #     ValueError: é‡ã¿ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã‹ã€ç„¡åŠ¹ãªå ´åˆã€‚
        #
        # ä¾‹:
        #     >>> model = Model()
        #     >>> model._load("yolo11n.pt")
        #     >>> model._load("path/to/weights.pth", task="detect")
        if weights.lower().startswith(("https://", "http://", "rtsp://", "rtmp://", "tcp://")):  # ã‚¦ã‚§ã‚¤ãƒˆãŒURLã‹ã‚‰å§‹ã¾ã‚‹å ´åˆ
            weights = checks.check_file(weights, download_dir=SETTINGS["weights_dir"])  # download and return local fileã€‚ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦è¿”ã™
        weights = checks.check_model_file_from_stem(weights)  # add suffix, i.e. yolov8n -> yolov8n.ptã€‚ã‚µãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’è¿½åŠ ã™ã‚‹ï¼ˆä¾‹ï¼šyolov8n -> yolov8n.ptï¼‰

        if Path(weights).suffix == ".pt":  # ã‚¦ã‚§ã‚¤ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ãŒ.ptã®å ´åˆ
            self.model, self.ckpt = attempt_load_one_weight(weights)  # ãƒ¢ãƒ‡ãƒ«ã¨ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’ãƒ­ãƒ¼ãƒ‰
            self.task = self.model.args["task"]  # ã‚¿ã‚¹ã‚¯ã‚’ãƒ­ãƒ¼ãƒ‰
            self.overrides = self.model.args = self._reset_ckpt_args(self.model.args)  # ä¸Šæ›¸ãè¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆ
            self.ckpt_path = self.model.pt_path  # ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãƒ‘ã‚¹ã‚’ãƒ­ãƒ¼ãƒ‰
        else:  # ã‚¦ã‚§ã‚¤ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ãŒ.ptã§ã¯ãªã„å ´åˆ
            weights = checks.check_file(weights)  # runs in all cases, not redundant with above callã€‚ã™ã¹ã¦ã®å ´åˆã«å®Ÿè¡Œ
            self.model, self.ckpt = weights, None  # ãƒ¢ãƒ‡ãƒ«ã¨ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’ã‚¦ã‚§ã‚¤ãƒˆã¨Noneã«è¨­å®š
            self.task = task or guess_model_task(weights)  # ã‚¿ã‚¹ã‚¯ã‚’æ¨æ¸¬
            self.ckpt_path = weights  # ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãƒ‘ã‚¹ã‚’ã‚¦ã‚§ã‚¤ãƒˆã«è¨­å®š
        self.overrides["model"] = weights  # ãƒ¢ãƒ‡ãƒ«ã®ä¸Šæ›¸ãè¨­å®šã‚’ã‚¦ã‚§ã‚¤ãƒˆã«è¨­å®š
        self.overrides["task"] = self.task  # ã‚¿ã‚¹ã‚¯ã®ä¸Šæ›¸ãè¨­å®šã‚’ã‚¿ã‚¹ã‚¯ã«è¨­å®š
        self.model_name = weights  # ãƒ¢ãƒ‡ãƒ«åã‚’ã‚¦ã‚§ã‚¤ãƒˆã«è¨­å®š

    def _check_is_pytorch_model(self) -> None:
        # ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã€ãã†ã§ãªã„å ´åˆã¯TypeErrorã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚
        # ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¾ãŸã¯.ptãƒ•ã‚¡ã‚¤ãƒ«ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚
        # PyTorchãƒ¢ãƒ‡ãƒ«ã‚’å¿…è¦ã¨ã™ã‚‹ç‰¹å®šã®æ“ä½œãŒã€äº’æ›æ€§ã®ã‚ã‚‹ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—ã§ã®ã¿å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
        #
        # ä¾‹å¤–:
        #     TypeError: ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¾ãŸã¯.ptãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯ãªã„å ´åˆã€‚
        #         ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã€ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãƒ¢ãƒ‡ãƒ«å½¢å¼ã¨æ“ä½œã«é–¢ã™ã‚‹è©³ç´°æƒ…å ±ã‚’æä¾›ã—ã¾ã™ã€‚
        #
        # ä¾‹:
        #     >>> model = Model("yolo11n.pt")
        #     >>> model._check_is_pytorch_model()  # ã‚¨ãƒ©ãƒ¼ã¯ç™ºç”Ÿã—ã¾ã›ã‚“
        #     >>> model = Model("yolov8n.onnx")
        #     >>> model._check_is_pytorch_model()  # TypeErrorãŒç™ºç”Ÿã—ã¾ã™
        pt_str = isinstance(self.model, (str, Path)) and Path(self.model).suffix == ".pt"  # ãƒ¢ãƒ‡ãƒ«ãŒæ–‡å­—åˆ—ã¾ãŸã¯Pathå‹ã§ã€æ‹¡å¼µå­ãŒ.ptã‹ã©ã†ã‹
        pt_module = isinstance(self.model, nn.Module)  # ãƒ¢ãƒ‡ãƒ«ãŒnn.Moduleã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‹ã©ã†ã‹
        if not (pt_module or pt_str):  # PyTorchãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¾ãŸã¯.ptãƒ•ã‚¡ã‚¤ãƒ«ã§ãªã„å ´åˆ
            raise TypeError(
                f"model='{self.model}' should be a *.pt PyTorch model to run this method, but is a different format. "
                f"PyTorch models can train, val, predict and export, i.e. 'model.train(data=...)', but exported "
                f"formats like ONNX, TensorRT etc. only support 'predict' and 'val' modes, "
                f"i.e. 'yolo predict model=yolov8n.onnx'.\nTo run CUDA or MPS inference please pass the device "
                f"argument directly in your inference command, i.e. 'model.predict(source=..., device=0)'"
            )

    def reset_weights(self) -> "Model":
        # ãƒ¢ãƒ‡ãƒ«ã®é‡ã¿ã‚’åˆæœŸçŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚
        # ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ¢ãƒ‡ãƒ«å†…ã®ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åå¾©å‡¦ç†ã—ã€'reset_parameters'ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚‹å ´åˆã¯ãã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚
        # ã¾ãŸã€ã™ã¹ã¦ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®'requires_grad'ãŒTrueã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ä¸­ã«æ›´æ–°ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
        #
        # æˆ»ã‚Šå€¤:
        #     (Model): é‡ã¿ã‚’ãƒªã‚»ãƒƒãƒˆã—ãŸã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€‚
        #
        # ä¾‹å¤–:
        #     AssertionError: ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ã¯ãªã„å ´åˆã€‚
        #
        # ä¾‹:
        #     >>> model = Model("yolo11n.pt")
        #     >>> model.reset_weights()
        self._check_is_pytorch_model()  # PyTorchãƒ¢ãƒ‡ãƒ«ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
        for m in self.model.modules():  # ãƒ¢ãƒ‡ãƒ«å†…ã®ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åå¾©å‡¦ç†
            if hasattr(m, "reset_parameters"):  # ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒreset_parameterså±æ€§ã‚’æŒã£ã¦ã„ã‚‹å ´åˆ
                m.reset_parameters()  # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ
        for p in self.model.parameters():  # ãƒ¢ãƒ‡ãƒ«å†…ã®ã™ã¹ã¦ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’åå¾©å‡¦ç†
            p.requires_grad = True  # requires_gradã‚’Trueã«è¨­å®š
        return self  # è‡ªèº«ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™

    def load(self, weights: Union[str, Path] = "yolo11n.pt") -> "Model":
        # æŒ‡å®šã•ã‚ŒãŸé‡ã¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒ¢ãƒ‡ãƒ«ã«ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚
        # ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã€ã¾ãŸã¯é‡ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ç›´æ¥é‡ã¿ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚
        # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’åå‰ã¨å½¢çŠ¶ã§ç…§åˆã—ã€ãƒ¢ãƒ‡ãƒ«ã«è»¢é€ã—ã¾ã™ã€‚
        #
        # å¼•æ•°:
        #     weights (Union[str, Path]): é‡ã¿ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯é‡ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒ‘ã‚¹ã€‚
        #
        # æˆ»ã‚Šå€¤:
        #     (Model): é‡ã¿ã‚’ãƒ­ãƒ¼ãƒ‰ã—ãŸã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€‚
        #
        # ä¾‹å¤–:
        #     AssertionError: ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ã¯ãªã„å ´åˆã€‚
        #
        # ä¾‹:
        #     >>> model = Model()
        #     >>> model.load("yolo11n.pt")
        #     >>> model.load(Path("path/to/weights.pt"))
        self._check_is_pytorch_model()  # PyTorchãƒ¢ãƒ‡ãƒ«ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
        if isinstance(weights, (str, Path)):  # ã‚¦ã‚§ã‚¤ãƒˆãŒæ–‡å­—åˆ—ã¾ãŸã¯Pathå‹ã®å ´åˆ
            self.overrides["pretrained"] = weights  # remember the weights for DDP trainingã€‚DDPãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã®ãŸã‚ã«ã‚¦ã‚§ã‚¤ãƒˆã‚’è¨˜æ†¶
            weights, self.ckpt = attempt_load_one_weight(weights)  # ãƒ¢ãƒ‡ãƒ«ã¨ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’ãƒ­ãƒ¼ãƒ‰
        self.model.load(weights)  # ãƒ¢ãƒ‡ãƒ«ã«ã‚¦ã‚§ã‚¤ãƒˆã‚’ãƒ­ãƒ¼ãƒ‰
        return self  # è‡ªèº«ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™

    def save(self, filename: Union[str, Path] = "saved_model.pt") -> None:
        # ç¾åœ¨ã®ãƒ¢ãƒ‡ãƒ«ã®çŠ¶æ…‹ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ã—ã¾ã™ã€‚
        # ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ¢ãƒ‡ãƒ«ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆï¼ˆckptï¼‰ã‚’æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«åã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚
        # æ—¥ä»˜ã€Ultralyticsãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€ãƒ©ã‚¤ã‚»ãƒ³ã‚¹æƒ…å ±ã€ãŠã‚ˆã³ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¸ã®ãƒªãƒ³ã‚¯ãªã©ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
        #
        # å¼•æ•°:
        #     filename (Union[str, Path]): ãƒ¢ãƒ‡ãƒ«ã®ä¿å­˜å…ˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰ã€‚
        #
        # ä¾‹å¤–:
        #     AssertionError: ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ã¯ãªã„å ´åˆã€‚
        #
        # ä¾‹:
        #     >>> model = Model("yolo11n.pt")
        #     >>> model.save("my_model.pt")
        self._check_is_pytorch_model()  # PyTorchãƒ¢ãƒ‡ãƒ«ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
        from copy import deepcopy  # æ·±ã„ã‚³ãƒ”ãƒ¼ã‚’è¡Œã†ãŸã‚ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        from datetime import datetime  # æ—¥ä»˜ã¨æ™‚åˆ»ã‚’æ‰±ã†ãŸã‚ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

        from ultralytics import __version__  # Ultralyticsã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

        updates = {  # ä¿å­˜ã™ã‚‹æƒ…å ±ã®è¾æ›¸
            "model": deepcopy(self.model).half() if isinstance(self.model, nn.Module) else self.model,  # ãƒ¢ãƒ‡ãƒ«ã®ã‚³ãƒ”ãƒ¼ï¼ˆnn.Moduleã®å ´åˆã€åŠç²¾åº¦ã«å¤‰æ›ï¼‰
            "date": datetime.now().isoformat(),  # ç¾åœ¨ã®æ—¥ä»˜ã¨æ™‚åˆ»
            "version": __version__,  # Ultralyticsã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³
           "license": "AGPL-3.0 License (https://ultralytics.com/license)",  # ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ï¼šAGPL-3.0 Licenseï¼ˆhttps://ultralytics.com/licenseï¼‰
            "docs": "https://docs.ultralytics.com",  # ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆï¼šhttps://docs.ultralytics.com
        }
        torch.save({**self.ckpt, **updates}, filename)  # ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆ(self.ckpt)ã¨æ›´æ–°æƒ…å ±(updates)ã‚’filenameã«ä¿å­˜

    def info(self, detailed: bool = False, verbose: bool = True):
        """
        ãƒ¢ãƒ‡ãƒ«æƒ…å ±ã‚’ãƒ­ã‚°å‡ºåŠ›ã¾ãŸã¯è¿”ã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æ¸¡ã•ã‚ŒãŸå¼•æ•°ã«å¿œã˜ã¦ã€ãƒ¢ãƒ‡ãƒ«ã®æ¦‚è¦ã¾ãŸã¯è©³ç´°æƒ…å ±ã‚’æä¾›ã—ã¾ã™ã€‚
        å‡ºåŠ›ã®å†—é•·æ€§ã‚’åˆ¶å¾¡ã—ã€æƒ…å ±ã‚’ãƒªã‚¹ãƒˆã¨ã—ã¦è¿”ã™ã“ã¨ãŒã§ãã¾ã™ã€‚

        Args:
            detailed (bool): Trueã®å ´åˆã€ãƒ¢ãƒ‡ãƒ«ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«é–¢ã™ã‚‹è©³ç´°æƒ…å ±ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
            verbose (bool): Trueã®å ´åˆã€æƒ…å ±ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚ Falseã®å ´åˆã€æƒ…å ±ã‚’ãƒªã‚¹ãƒˆã¨ã—ã¦è¿”ã—ã¾ã™ã€‚

        Returns:
            (List[str]): ãƒ¢ãƒ‡ãƒ«ã®æ¦‚è¦ã€ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è©³ç´°ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ•°ãªã©ã€ãƒ¢ãƒ‡ãƒ«ã«é–¢ã™ã‚‹ã•ã¾ã–ã¾ãªç¨®é¡ã®æƒ…å ±ã‚’å«ã‚€æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã€‚
            verboseãŒTrueã®å ´åˆã¯ç©ºã§ã™ã€‚

        Raises:
            TypeError: ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ãªã„å ´åˆã€‚

        Examples:
            >>> model = Model("yolo11n.pt")
            >>> model.info()  # ãƒ¢ãƒ‡ãƒ«ã®æ¦‚è¦ã‚’å‡ºåŠ›
            >>> info_list = model.info(detailed=True, verbose=False)  # è©³ç´°æƒ…å ±ã‚’ãƒªã‚¹ãƒˆã¨ã—ã¦è¿”ã™
        """
        self._check_is_pytorch_model()  # ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
        return self.model.info(detailed=detailed, verbose=verbose)  # ãƒ¢ãƒ‡ãƒ«æƒ…å ±ã‚’å–å¾—ã—ã¦è¿”ã™

    def fuse(self):
        """
        æœ€é©åŒ–ã•ã‚ŒãŸæ¨è«–ã®ãŸã‚ã«ã€ãƒ¢ãƒ‡ãƒ«å†…ã®Conv2dãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨BatchNorm2dãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’èåˆã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ¢ãƒ‡ãƒ«ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åå¾©å‡¦ç†ã—ã€é€£ç¶šã™ã‚‹Conv2dãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨BatchNorm2dãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å˜ä¸€ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«èåˆã—ã¾ã™ã€‚
        ã“ã®èåˆã«ã‚ˆã‚Šã€é †æ–¹å‘ãƒ‘ã‚¹ä¸­ã«å¿…è¦ãªæ“ä½œã¨ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹ã®å›æ•°ã‚’æ¸›ã‚‰ã™ã“ã¨ã§ã€æ¨è«–é€Ÿåº¦ã‚’å¤§å¹…ã«å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

        èåˆãƒ—ãƒ­ã‚»ã‚¹ã«ã¯é€šå¸¸ã€BatchNorm2dãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆå¹³å‡ã€åˆ†æ•£ã€é‡ã¿ã€ãƒã‚¤ã‚¢ã‚¹ï¼‰ã‚’å‰ã®Conv2dãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é‡ã¿ã¨ãƒã‚¤ã‚¢ã‚¹ã«ç•³ã¿è¾¼ã‚€ã“ã¨ãŒå«ã¾ã‚Œã¾ã™ã€‚
        ã“ã‚Œã«ã‚ˆã‚Šã€ç•³ã¿è¾¼ã¿ã¨æ­£è¦åŒ–ã‚’1ã¤ã®ã‚¹ãƒ†ãƒƒãƒ—ã§å®Ÿè¡Œã™ã‚‹å˜ä¸€ã®Conv2dãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚

        Raises:
            TypeError: ãƒ¢ãƒ‡ãƒ«ãŒPyTorch nn.Moduleã§ãªã„å ´åˆã€‚

        Examples:
            >>> model = Model("yolo11n.pt")
            >>> model.fuse()
            >>> # ãƒ¢ãƒ‡ãƒ«ãŒèåˆã•ã‚Œã€æœ€é©åŒ–ã•ã‚ŒãŸæ¨è«–ã®æº–å‚™ãŒã§ãã¾ã—ãŸ
        """
        self._check_is_pytorch_model()  # ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
        self.model.fuse()  # ãƒ¢ãƒ‡ãƒ«ã®Conv2dãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨BatchNorm2dãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’èåˆ

    def embed(
        self,
        source: Union[str, Path, int, list, tuple, np.ndarray, torch.Tensor] = None,  # å…¥åŠ›ã‚½ãƒ¼ã‚¹ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã€URLã€PILã‚¤ãƒ¡ãƒ¼ã‚¸ã€numpyé…åˆ—ã€torchãƒ†ãƒ³ã‚½ãƒ«ãªã©
        stream: bool = False,  # ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§å‡¦ç†ã™ã‚‹ã‹ã©ã†ã‹ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯False
        **kwargs,  # ãã®ä»–ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°
    ) -> list:
        """
        æŒ‡å®šã•ã‚ŒãŸã‚½ãƒ¼ã‚¹ã«åŸºã¥ã„ã¦ç”»åƒåŸ‹ã‚è¾¼ã¿ã‚’ç”Ÿæˆã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯`predict()`ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã§ã‚ã‚Šã€ç”»åƒã‚½ãƒ¼ã‚¹ã‹ã‚‰åŸ‹ã‚è¾¼ã¿ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã«ç„¦ç‚¹ã‚’å½“ã¦ã¦ã„ã¾ã™ã€‚
        ã•ã¾ã–ã¾ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ä½¿ç”¨ã—ã¦ã€åŸ‹ã‚è¾¼ã¿ãƒ—ãƒ­ã‚»ã‚¹ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚

        Args:
            source (str | Path | int | List | Tuple | np.ndarray | torch.Tensor): åŸ‹ã‚è¾¼ã¿ã‚’ç”Ÿæˆã™ã‚‹ç”»åƒã®ã‚½ãƒ¼ã‚¹ã€‚
                ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã€URLã€PILã‚¤ãƒ¡ãƒ¼ã‚¸ã€numpyé…åˆ—ãªã©ã‚’æŒ‡å®šã§ãã¾ã™ã€‚
            stream (bool): Trueã®å ´åˆã€äºˆæ¸¬ã¯ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã•ã‚Œã¾ã™ã€‚
            **kwargs (Any): åŸ‹ã‚è¾¼ã¿ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ§‹æˆã™ã‚‹ãŸã‚ã®è¿½åŠ ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã€‚

        Returns:
            (List[torch.Tensor]): ç”»åƒåŸ‹ã‚è¾¼ã¿ã‚’å«ã‚€ãƒªã‚¹ãƒˆã€‚

        Raises:
            AssertionError: ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ãªã„å ´åˆã€‚

        Examples:
            >>> model = YOLO("yolo11n.pt")
            >>> image = "https://ultralytics.com/images/bus.jpg"
            >>> embeddings = model.embed(image)
            >>> print(embeddings[0].shape)
        """
        if not kwargs.get("embed"):  # 'embed'ã‚­ãƒ¼ãŒkwargsã«å­˜åœ¨ã—ãªã„å ´åˆ
            kwargs["embed"] = [len(self.model.model) - 2]  # ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒæ¸¡ã•ã‚Œãªã‹ã£ãŸå ´åˆã€æœ€å¾Œã‹ã‚‰2ç•ªç›®ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åŸ‹ã‚è¾¼ã¿ã¾ã™ã€‚
        return self.predict(source, stream, **kwargs)  # predictãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã€åŸ‹ã‚è¾¼ã¿ã‚’ç”Ÿæˆ

    def predict(
        self,
        source: Union[str, Path, int, Image.Image, list, tuple, np.ndarray, torch.Tensor] = None,  # å…¥åŠ›ã‚½ãƒ¼ã‚¹ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã€URLã€PILã‚¤ãƒ¡ãƒ¼ã‚¸ã€numpyé…åˆ—ã€torchãƒ†ãƒ³ã‚½ãƒ«ãªã©
        stream: bool = False,  # ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§å‡¦ç†ã™ã‚‹ã‹ã©ã†ã‹ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯False
        predictor=None,  # ã‚«ã‚¹ã‚¿ãƒ predictorã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯None
        **kwargs,  # ãã®ä»–ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°
    ) -> List[Results]:
        """
        YOLOãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨ã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸç”»åƒã‚½ãƒ¼ã‚¹ã§äºˆæ¸¬ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã‚’ä½¿ç”¨ã—ã¦ã•ã¾ã–ã¾ãªæ§‹æˆã‚’å¯èƒ½ã«ã—ã€äºˆæ¸¬ãƒ—ãƒ­ã‚»ã‚¹ã‚’å®¹æ˜“ã«ã—ã¾ã™ã€‚
        ã‚«ã‚¹ã‚¿ãƒ predictorã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®predictorãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ãŸäºˆæ¸¬ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚
        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã•ã¾ã–ã¾ãªã‚¿ã‚¤ãƒ—ã®ç”»åƒã‚½ãƒ¼ã‚¹ã‚’å‡¦ç†ã—ã€ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã§å‹•ä½œã§ãã¾ã™ã€‚

        Args:
            source (str | Path | int | PIL.Image | np.ndarray | torch.Tensor | List | Tuple): äºˆæ¸¬ã‚’è¡Œã†ç”»åƒã®ã‚½ãƒ¼ã‚¹ã€‚
                ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã€URLã€PILã‚¤ãƒ¡ãƒ¼ã‚¸ã€numpyé…åˆ—ã€torchãƒ†ãƒ³ã‚½ãƒ«ãªã©ã®ã•ã¾ã–ã¾ãªã‚¿ã‚¤ãƒ—ã‚’å—ã‘å…¥ã‚Œã¾ã™ã€‚
            stream (bool): Trueã®å ´åˆã€å…¥åŠ›ã‚½ãƒ¼ã‚¹ã‚’äºˆæ¸¬ç”¨ã®é€£ç¶šã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚
            predictor (BasePredictor | None): äºˆæ¸¬ã‚’è¡Œã†ãŸã‚ã®ã‚«ã‚¹ã‚¿ãƒ predictorã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€‚
                Noneã®å ´åˆã€ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®predictorã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
            **kwargs (Any): äºˆæ¸¬ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ§‹æˆã™ã‚‹ãŸã‚ã®è¿½åŠ ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã€‚

        Returns:
            (List[ultralytics.engine.results.Results]): äºˆæ¸¬çµæœã®ãƒªã‚¹ãƒˆã€‚å„çµæœã¯Resultsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚«ãƒ—ã‚»ãƒ«åŒ–ã•ã‚Œã¾ã™ã€‚

        Examples:
            >>> model = YOLO("yolo11n.pt")
            >>> results = model.predict(source="path/to/image.jpg", conf=0.25)
            >>> for r in results:
            ...     print(r.boxes.data)  # æ¤œå‡ºã•ã‚ŒãŸãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’å‡ºåŠ›

        Notes:
            - ã€Œsourceã€ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€è­¦å‘Šã¨ã¨ã‚‚ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ASSETSå®šæ•°ã«ãªã‚Šã¾ã™ã€‚
            - ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æ–°ã—ã„predictorãŒã¾ã å­˜åœ¨ã—ãªã„å ´åˆã«ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã€å„å‘¼ã³å‡ºã—ã§ãã®å¼•æ•°ã‚’æ›´æ–°ã—ã¾ã™ã€‚
            - SAMã‚¿ã‚¤ãƒ—ã®ãƒ¢ãƒ‡ãƒ«ã®å ´åˆã€ã€Œpromptsã€ã‚’ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã¨ã—ã¦æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚
        """
        if source is None:  # ã‚½ãƒ¼ã‚¹ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆ
            source = ASSETS  # ã‚½ãƒ¼ã‚¹ã‚’ã‚¢ã‚»ãƒƒãƒˆã«è¨­å®š
            LOGGER.warning(f"WARNING âš ï¸ 'source' is missing. Using 'source={source}'.")  # è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¨˜éŒ²

        is_cli = (ARGV[0].endswith("yolo") or ARGV[0].endswith("ultralytics")) and any(  # CLIç’°å¢ƒã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
            x in ARGV for x in ("predict", "track", "mode=predict", "mode=track")
        )

        custom = {"conf": 0.25, "batch": 1, "save": is_cli, "mode": "predict"}  # ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
        args = {**self.overrides, **custom, **kwargs}  # å„ªå…ˆåº¦ã®é«˜ã„é †ã«å¼•æ•°ã‚’çµåˆ
        prompts = args.pop("prompts", None)  # SAMã‚¿ã‚¤ãƒ—ã®ãƒ¢ãƒ‡ãƒ«ç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ

        if not self.predictor:  # predictorãŒã¾ã è¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆ
            self.predictor = (predictor or self._smart_load("predictor"))(overrides=args, _callbacks=self.callbacks)  # predictorã‚’ãƒ­ãƒ¼ãƒ‰
            self.predictor.setup_model(model=self.model, verbose=is_cli)  # predictorã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        else:  # predictorãŒã™ã§ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ã€å¼•æ•°ã‚’æ›´æ–°
            self.predictor.args = get_cfg(self.predictor.args, args) # predictorã®å¼•æ•°ã‚’æ›´æ–°
            if "project" in args or "name" in args: # projectã¾ãŸã¯nameå¼•æ•°ãŒæ¸¡ã•ã‚ŒãŸå ´åˆ
                self.predictor.save_dir = get_save_dir(self.predictor.args) # ä¿å­˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æ›´æ–°

        if prompts and hasattr(self.predictor, "set_prompts"):  # SAMã‚¿ã‚¤ãƒ—ã®ãƒ¢ãƒ‡ãƒ«ã®å ´åˆã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è¨­å®š
            self.predictor.set_prompts(prompts) # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è¨­å®š

        return self.predictor.predict_cli(source=source) if is_cli else self.predictor(source=source, stream=stream)  # äºˆæ¸¬ã‚’å®Ÿè¡Œ
    
    def track(
        self,
        source: Union[str, Path, int, list, tuple, np.ndarray, torch.Tensor] = None,  # å…¥åŠ›ã‚½ãƒ¼ã‚¹ï¼šãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã€URLã€PILã‚¤ãƒ¡ãƒ¼ã‚¸ã€numpyé…åˆ—ã€torchãƒ†ãƒ³ã‚½ãƒ«ãªã©
        stream: bool = False,  # ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å…¥åŠ›ã‹ã©ã†ã‹ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯False
        persist: bool = False,  # ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’æ°¸ç¶šåŒ–ã™ã‚‹ã‹ã©ã†ã‹ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯False
        **kwargs,  # ãã®ä»–ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°
    ) -> List[Results]:
        """
        ç™»éŒ²ã•ã‚ŒãŸãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸå…¥åŠ›ã‚½ãƒ¼ã‚¹ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¿½è·¡ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ¢ãƒ‡ãƒ«ã®äºˆæ¸¬å­ã¨ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ç™»éŒ²ã•ã‚ŒãŸãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¿½è·¡ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
        ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚„ãƒ“ãƒ‡ã‚ªã‚¹ãƒˆãƒªãƒ¼ãƒ ãªã©ã®ã•ã¾ã–ã¾ãªå…¥åŠ›ã‚½ãƒ¼ã‚¹ã‚’å‡¦ç†ã—ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã«ã‚ˆã‚‹ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚
        ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒˆãƒ©ãƒƒã‚«ãƒ¼ãŒã¾ã å­˜åœ¨ã—ãªã„å ´åˆã«ç™»éŒ²ã—ã€å‘¼ã³å‡ºã—é–“ã§ãã‚Œã‚‰ã‚’æ°¸ç¶šåŒ–ã§ãã¾ã™ã€‚

        Args:
            source (Union[str, Path, int, List, Tuple, np.ndarray, torch.Tensor], optional): ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¿½è·¡ã®å…¥åŠ›ã‚½ãƒ¼ã‚¹ã€‚
                ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã€URLã€ã¾ãŸã¯ãƒ“ãƒ‡ã‚ªã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æŒ‡å®šã§ãã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯Noneã§ã™ã€‚
            stream (bool): Trueã®å ´åˆã€å…¥åŠ›ã‚½ãƒ¼ã‚¹ã‚’é€£ç¶šãƒ“ãƒ‡ã‚ªã‚¹ãƒˆãƒªãƒ¼ãƒ ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯Falseã§ã™ã€‚
            persist (bool): Trueã®å ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ç•°ãªã‚‹å‘¼ã³å‡ºã—é–“ã§ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’æ°¸ç¶šåŒ–ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯Falseã§ã™ã€‚
            **kwargs (Any): è¿½è·¡ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ§‹æˆã™ã‚‹ãŸã‚ã®è¿½åŠ ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã€‚

        Returns:
            (List[ultralytics.engine.results.Results]): è¿½è·¡çµæœã®ãƒªã‚¹ãƒˆã€‚å„çµæœã¯Resultsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚

        Raises:
            AttributeError: äºˆæ¸¬å­ãŒç™»éŒ²ã•ã‚ŒãŸãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’æŒã£ã¦ã„ãªã„å ´åˆã€‚

        Examples:
            >>> model = YOLO("yolo11n.pt")
            >>> results = model.track(source="path/to/video.mp4", show=True)
            >>> for r in results:
            ...     print(r.boxes.id)  # è¿½è·¡IDã‚’å‡ºåŠ›

        Notes:
            - ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ByteTrackãƒ™ãƒ¼ã‚¹ã®è¿½è·¡ã«å¯¾ã—ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ä¿¡é ¼åº¦ã—ãã„å€¤0.1ã‚’è¨­å®šã—ã¾ã™ã€‚
            - è¿½è·¡ãƒ¢ãƒ¼ãƒ‰ã¯ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã§æ˜ç¤ºçš„ã«è¨­å®šã•ã‚Œã¾ã™ã€‚
            - ãƒãƒƒãƒã‚µã‚¤ã‚ºã¯ã€ãƒ“ãƒ‡ã‚ªã®è¿½è·¡ç”¨ã«1ã«è¨­å®šã•ã‚Œã¾ã™ã€‚
        """
        if not hasattr(self.predictor, "trackers"):  # predictorãŒãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’æŒã£ã¦ã„ãªã„å ´åˆ
            from trackers import register_tracker  # ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’ç™»éŒ²ã™ã‚‹é–¢æ•°ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

            register_tracker(self, persist)  # ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’ç™»éŒ²
        kwargs["conf"] = kwargs.get("conf") or 0.1  # ByteTrackãƒ™ãƒ¼ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å…¥åŠ›ã¨ã—ã¦ä½ã„ä¿¡é ¼åº¦ã®äºˆæ¸¬ã‚’å¿…è¦ã¨ã—ã¾ã™
        kwargs["batch"] = kwargs.get("batch") or 1  # ãƒ“ãƒ‡ã‚ªã§ã®è¿½è·¡ã®å ´åˆã€ãƒãƒƒãƒã‚µã‚¤ã‚ºã¯1
        kwargs["mode"] = "track"  # è¿½è·¡ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®š
        return self.predict(source=source, stream=stream, **kwargs)  # äºˆæ¸¬ã‚’å®Ÿè¡Œã—ã¦è¿½è·¡çµæœã‚’è¿”ã™

    def val(
        self,
        validator=None,  # ã‚«ã‚¹ã‚¿ãƒ validatorã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯None
        **kwargs,  # ãã®ä»–ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°
    ):
        """
        æŒ‡å®šã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã¨æ¤œè¨¼æ§‹æˆã‚’ä½¿ç”¨ã—ã¦ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œè¨¼ã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã•ã¾ã–ã¾ãªè¨­å®šã«ã‚ˆã‚‹ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚’å¯èƒ½ã«ã—ã€ãƒ¢ãƒ‡ãƒ«æ¤œè¨¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’å®¹æ˜“ã«ã—ã¾ã™ã€‚
        ã‚«ã‚¹ã‚¿ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚¿ãƒ¼ã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ¤œè¨¼ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ã‚ˆã‚‹æ¤œè¨¼ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚
        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ§‹æˆã€ãƒ¡ã‚½ãƒƒãƒ‰å›ºæœ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã€ãŠã‚ˆã³ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæŒ‡å®šã—ãŸå¼•æ•°ã‚’çµ„ã¿åˆã‚ã›ã¦ã€æ¤œè¨¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ§‹æˆã—ã¾ã™ã€‚

        Args:
            validator (ultralytics.engine.validator.BaseValidator | None): ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œè¨¼ã™ã‚‹ãŸã‚ã®ã‚«ã‚¹ã‚¿ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚¿ãƒ¼ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€‚
            **kwargs (Any): æ¤œè¨¼ãƒ—ãƒ­ã‚»ã‚¹ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ãŸã‚ã®ä»»æ„ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã€‚

        Returns:
            (ultralytics.utils.metrics.DetMetrics): æ¤œè¨¼ãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰å–å¾—ã•ã‚ŒãŸæ¤œè¨¼ãƒ¡ãƒˆãƒªãƒƒã‚¯ã€‚

        Raises:
            AssertionError: ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ãªã„å ´åˆã€‚

        Examples:
            >>> model = YOLO("yolo11n.pt")
            >>> results = model.val(data="coco8.yaml", imgsz=640)
            >>> print(results.box.map)  # mAP50-95ã‚’å‡ºåŠ›
        """
        custom = {"rect": True}  # method defaultsã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°
        args = {**self.overrides, **custom, **kwargs, "mode": "val"}  # highest priority args on the rightã€‚å¼•æ•°ã‚’çµåˆ

        validator = (validator or self._smart_load("validator"))(args=args, _callbacks=self.callbacks)  # validatorã‚’åˆæœŸåŒ–
        validator(model=self.model)  # ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œè¨¼
        self.metrics = validator.metrics  # ãƒ¡ãƒˆãƒªãƒƒã‚¯ã‚’ä¿å­˜
        return validator.metrics  # æ¤œè¨¼ãƒ¡ãƒˆãƒªãƒƒã‚¯ã‚’è¿”ã™

    def benchmark(
        self,
        **kwargs,  # ãã®ä»–ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°
    ):
        """
        ã•ã¾ã–ã¾ãªã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå½¢å¼ã§ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã—ã¦ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’è©•ä¾¡ã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ONNXã€TorchScriptãªã©ã®ã•ã¾ã–ã¾ãªã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå½¢å¼ã§ã®ãƒ¢ãƒ‡ãƒ«ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’è©•ä¾¡ã—ã¾ã™ã€‚
        ultralytics.utils.benchmarksãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã€Œbenchmarkã€é–¢æ•°ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
        ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ§‹æˆå€¤ã€ãƒ¢ãƒ‡ãƒ«å›ºæœ‰ã®å¼•æ•°ã€ãƒ¡ã‚½ãƒƒãƒ‰å›ºæœ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã€ãŠã‚ˆã³è¿½åŠ ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®šã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã®çµ„ã¿åˆã‚ã›ã‚’ä½¿ç”¨ã—ã¦æ§‹æˆã•ã‚Œã¾ã™ã€‚

        Args:
            **kwargs (Any): ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ—ãƒ­ã‚»ã‚¹ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ãŸã‚ã®ä»»æ„ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã€‚ã“ã‚Œã‚‰ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ§‹æˆã€ãƒ¢ãƒ‡ãƒ«å›ºæœ‰ã®å¼•æ•°ã€ãŠã‚ˆã³ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨çµ„ã¿åˆã‚ã•ã‚Œã¾ã™ã€‚
                ä¸€èˆ¬çš„ãªã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚
                - data (str): ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ç”¨ã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã¸ã®ãƒ‘ã‚¹ã€‚
                - imgsz (int | List[int]): ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ç”¨ã®ç”»åƒã‚µã‚¤ã‚ºã€‚
                - half (bool): åŠç²¾åº¦ï¼ˆFP16ï¼‰ãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã©ã†ã‹ã€‚
                - int8 (bool): int8ç²¾åº¦ãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã©ã†ã‹ã€‚
                - device (str): ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ãƒ‡ãƒã‚¤ã‚¹ï¼ˆä¾‹ï¼š'cpu'ã€'cuda'ï¼‰ã€‚
                - verbose (bool): è©³ç´°ãªãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯æƒ…å ±ã‚’å‡ºåŠ›ã™ã‚‹ã‹ã©ã†ã‹ã€‚

        Returns:
            (Dict): ã•ã¾ã–ã¾ãªã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå½¢å¼ã®ãƒ¡ãƒˆãƒªãƒƒã‚¯ã‚’å«ã‚€ã€ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ—ãƒ­ã‚»ã‚¹ã®çµæœã‚’å«ã‚€è¾æ›¸ã€‚

        Raises:
            AssertionError: ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ãªã„å ´åˆã€‚

        Examples:
            >>> model = YOLO("yolo11n.pt")
            >>> results = model.benchmark(data="coco8.yaml", imgsz=640, half=True)
            >>> print(results)
        """
        self._check_is_pytorch_model()  # ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
        from utils.benchmarks import benchmark  # ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–¢æ•°ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

        custom = {"verbose": False}  # method defaultsã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°
        args = {**DEFAULT_CFG_DICT, **self.model.args, **custom, **kwargs, "mode": "benchmark"}  # å¼•æ•°ã‚’çµåˆ
        return benchmark(  # ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã‚’å®Ÿè¡Œ
            model=self,
            data=kwargs.get("data"),  # 'data'å¼•æ•°ãŒæ¸¡ã•ã‚Œãªã„å ´åˆã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã«å¯¾ã—ã¦data = Noneã‚’è¨­å®šã—ã¾ã™ã€‚
            imgsz=args["imgsz"],
            half=args["half"],
            int8=args["int8"],
            device=args["device"],
            verbose=kwargs.get("verbose"),
        )

    def export(
        self,
        **kwargs,  # ãã®ä»–ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°
    ) -> str:
        """
        ãƒ‡ãƒ—ãƒ­ã‚¤ã«é©ã—ãŸåˆ¥ã®å½¢å¼ã«ãƒ¢ãƒ‡ãƒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã®ç›®çš„ã§ãƒ¢ãƒ‡ãƒ«ã‚’ã•ã¾ã–ã¾ãªå½¢å¼ï¼ˆãŸã¨ãˆã°ã€ONNXã€TorchScriptï¼‰ã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã‚’å®¹æ˜“ã«ã—ã¾ã™ã€‚
        ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã«ã¯ã€ŒExporterã€ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ã—ã€ãƒ¢ãƒ‡ãƒ«å›ºæœ‰ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã€ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã€ãŠã‚ˆã³è¿½åŠ ã®å¼•æ•°ã‚’çµ„ã¿åˆã‚ã›ã¦ä½¿ç”¨â€‹â€‹ã—ã¾ã™ã€‚

        Args:
            **kwargs (Dict): ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ãŸã‚ã®ä»»æ„ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã€‚
            ã“ã‚Œã‚‰ã¯ã€ãƒ¢ãƒ‡ãƒ«ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ãŠã‚ˆã³ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨çµ„ã¿åˆã‚ã•ã‚Œã¾ã™ã€‚
            ä¸€èˆ¬çš„ãªå¼•æ•°ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚
                format (str): ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå½¢å¼ï¼ˆä¾‹ï¼šã€Œonnxã€ã€ã€Œã‚¨ãƒ³ã‚¸ãƒ³ã€ã€ã€Œcoremlã€ï¼‰ã€‚
                half (bool): åŠç²¾åº¦ã§ãƒ¢ãƒ‡ãƒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚
                int8 (bool): int8ç²¾åº¦ã§ãƒ¢ãƒ‡ãƒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚
                device (str): ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚’å®Ÿè¡Œã™ã‚‹ãƒ‡ãƒã‚¤ã‚¹ã€‚
                workspace (int): TensorRTã‚¨ãƒ³ã‚¸ãƒ³ã®æœ€å¤§ãƒ¡ãƒ¢ãƒªãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‚µã‚¤ã‚ºã€‚
                nms (bool): ãƒ¢ãƒ‡ãƒ«ã«Non-Maximum Suppressionï¼ˆNMSï¼‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿½åŠ ã—ã¾ã™ã€‚
                simplify (bool): ONNXãƒ¢ãƒ‡ãƒ«ã‚’ç°¡ç•¥åŒ–ã—ã¾ã™ã€‚

        Returns:
            (str): ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã€‚

        Raises:
            AssertionError: ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ãªã„å ´åˆã€‚
            ValueError: ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå½¢å¼ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€‚
            RuntimeError: ã‚¨ãƒ©ãƒ¼ãŒåŸå› ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ—ãƒ­ã‚»ã‚¹ãŒå¤±æ•—ã—ãŸå ´åˆã€‚

        Examples:
            >>> model = YOLO("yolo11n.pt")
            >>> model.export(format="onnx", dynamic=True, simplify=True)
            'path/to/exported/model.onnx'
        """
        self._check_is_pytorch_model()  # ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
        from .exporter import Exporter  # Exporterã‚¯ãƒ©ã‚¹ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

        custom = {
            "imgsz": self.model.args["imgsz"],
            "batch": 1,
            "data": None,
            "device": None,  # ãƒãƒ«ãƒGPUã‚¨ãƒ©ãƒ¼ã‚’å›é¿ã™ã‚‹ãŸã‚ã«ãƒªã‚»ãƒƒãƒˆ
            "verbose": False,
        }  # ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        args = {**self.overrides, **custom, **kwargs, "mode": "export"}  # å„ªå…ˆåº¦ã®é«˜ã„é †ã«å¼•æ•°ã‚’çµåˆ
        return Exporter(overrides=args, _callbacks=self.callbacks)(model=self.model)  # ãƒ¢ãƒ‡ãƒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ

    def train(
        self,
        trainer=None,  # ã‚«ã‚¹ã‚¿ãƒ trainerã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯None
        **kwargs,  # ãã®ä»–ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°
    ):
        """
        æŒ‡å®šã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã¨ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°æ§‹æˆã‚’ä½¿ç”¨ã—ã¦ãƒ¢ãƒ‡ãƒ«ã‚’ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ãªã•ã¾ã–ã¾ãªè¨­å®šã§ãƒ¢ãƒ‡ãƒ«ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’å®¹æ˜“ã«ã—ã¾ã™ã€‚
        ã‚«ã‚¹ã‚¿ãƒ ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼ã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ã‚ˆã‚‹ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¾ã™ã€‚
        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‹ã‚‰ã®ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã®å†é–‹ã€Ultralytics HUBã¨ã®çµ±åˆã€ãŠã‚ˆã³ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°å¾Œã®ãƒ¢ãƒ‡ãƒ«ã¨æ§‹æˆã®æ›´æ–°ãªã©ã®ã‚·ãƒŠãƒªã‚ªã‚’å‡¦ç†ã—ã¾ã™ã€‚

        Ultralytics HUBã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ¢ãƒ‡ãƒ«ãŒã‚ã‚‹å ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯HUBãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°å¼•æ•°ã‚’å„ªå…ˆã—ã€ãƒ­ãƒ¼ã‚«ãƒ«å¼•æ•°ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã¯è­¦å‘Šã—ã¾ã™ã€‚
        pipã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã‚’ç¢ºèªã—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ§‹æˆã€ãƒ¡ã‚½ãƒƒãƒ‰å›ºæœ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã€ãŠã‚ˆã³ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæŒ‡å®šã—ãŸå¼•æ•°ã‚’çµ„ã¿åˆã‚ã›ã¦ã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ§‹æˆã—ã¾ã™ã€‚

        Args:
            trainer (BaseTrainer | None): ãƒ¢ãƒ‡ãƒ«ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ç”¨ã®ã‚«ã‚¹ã‚¿ãƒ ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€‚ Noneã®å ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
            **kwargs (Any): ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°æ§‹æˆç”¨ã®ä»»æ„ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã€‚ä¸€èˆ¬çš„ãªã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚
                data (str): ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆæ§‹æˆãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã€‚
                epochs (int): ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚¨ãƒãƒƒã‚¯æ•°ã€‚
                batch_size (int): ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã®ãƒãƒƒãƒã‚µã‚¤ã‚ºã€‚
                imgsz (int): å…¥åŠ›ç”»åƒã‚µã‚¤ã‚ºã€‚
                device (str): ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’å®Ÿè¡Œã™ã‚‹ãƒ‡ãƒã‚¤ã‚¹ï¼ˆä¾‹ï¼š'cuda'ã€'cpu'ï¼‰ã€‚
                workers (int): ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰ç”¨ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚¹ãƒ¬ãƒƒãƒ‰ã®æ•°ã€‚
                optimizer (str): ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã«ä½¿ç”¨ã™ã‚‹ã‚ªãƒ—ãƒ†ã‚£ãƒã‚¤ã‚¶ã€‚
                lr0 (float): åˆæœŸå­¦ç¿’ç‡ã€‚
                patience (int): ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã®æ—©æœŸåœæ­¢ã®ãŸã‚ã«è¦³å¯Ÿå¯èƒ½ãªæ”¹å–„ãŒãªã„å ´åˆã«å¾…æ©Ÿã™ã‚‹ã‚¨ãƒãƒƒã‚¯ã€‚

        Returns:
            (Dict | None): ä½¿ç”¨å¯èƒ½ã§ã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãŒæˆåŠŸã—ãŸå ´åˆã®ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ¡ãƒˆãƒªãƒƒã‚¯ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯Noneã€‚

        Raises:
            AssertionError: ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ãªã„å ´åˆã€‚
            PermissionError: HUBã‚»ãƒƒã‚·ãƒ§ãƒ³ã«æ¨©é™ã®å•é¡ŒãŒã‚ã‚‹å ´åˆã€‚
            ModuleNotFoundError: HUB SDKãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ãªã„å ´åˆã€‚

        Examples:
            >>> model = YOLO("yolo11n.pt")
            >>> results = model.train(data="coco8.yaml", epochs=3)
        """
        self._check_is_pytorch_model()  # ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
        if hasattr(self.session, "model") and self.session.model.id:  # ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨ã—ãŸUltralytics HUBã‚»ãƒƒã‚·ãƒ§ãƒ³
            if any(kwargs):
                LOGGER.warning("WARNING âš ï¸ HUBãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°å¼•æ•°ã‚’ä½¿ç”¨ã—ã¦ãŠã‚Šã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°å¼•æ•°ã¯ç„¡è¦–ã•ã‚Œã¾ã™ã€‚")  # è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¨˜éŒ²
            kwargs = self.session.train_args  # kwargsã‚’ä¸Šæ›¸ã

        checks.check_pip_update_available()  # pipã®ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã‚’ç¢ºèª

        overrides = yaml_load(checks.check_yaml(kwargs["cfg"])) if kwargs.get("cfg") else self.overrides  # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰
        custom = {
            # NOTE: 'cfg'ã«'data'ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã®å‡¦ç†ã€‚
            "data": overrides.get("data") or DEFAULT_CFG_DICT["data"] or TASK2DATA[self.task],  # ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®è¨­å®š
            "model": self.overrides["model"],  # ãƒ¢ãƒ‡ãƒ«ã‚’è¨­å®š
            "task": self.task,  # ã‚¿ã‚¹ã‚¯ã‚’è¨­å®š
        }  # ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        args = {**overrides, **custom, **kwargs, "mode": "train"}  # å„ªå…ˆåº¦ã®é«˜ã„é †ã«å¼•æ•°ã‚’çµåˆ
        if args.get("resume"):  # ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’å†é–‹ã™ã‚‹å ´åˆ
            args["resume"] = self.ckpt_path  # ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®ãƒ‘ã‚¹ã‚’è¨­å®š

        self.trainer = (trainer or self._smart_load("trainer"))(overrides=args, _callbacks=self.callbacks)  # trainerã‚’åˆæœŸåŒ–
        if not args.get("resume"):  # æ‰‹å‹•ã§ãƒ¢ãƒ‡ãƒ«ã‚’è¨­å®šï¼ˆå†é–‹ã—ãªã„å ´åˆã®ã¿ï¼‰
            self.trainer.model = self.trainer.get_model(weights=self.model if self.ckpt else None, cfg=self.model.yaml)  # ãƒ¢ãƒ‡ãƒ«ã‚’å–å¾—
            self.model = self.trainer.model  # ãƒ¢ãƒ‡ãƒ«ã‚’è¨­å®š

        self.trainer.hub_session = self.session  # ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®HUBã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ã‚¢ã‚¿ãƒƒãƒ
        self.trainer.train()  # ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’é–‹å§‹
        # ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°å¾Œã«ãƒ¢ãƒ‡ãƒ«ã¨cfgã‚’æ›´æ–°
        if RANK in {-1, 0}:  # ãƒ©ãƒ³ã‚¯ãŒ-1ã¾ãŸã¯0ã®å ´åˆ
            ckpt = self.trainer.best if self.trainer.best.exists() else self.trainer.last  # æœ€é«˜ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’å–å¾—
            self.model, _ = attempt_load_one_weight(ckpt)  # ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰
            self.overrides = self.model.args  # ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã‚’è¨­å®š
            self.metrics = getattr(self.trainer.validator, "metrics", None)  # ãƒ¡ãƒˆãƒªãƒƒã‚¯ã‚’å–å¾—
        return self.metrics  # ãƒ¡ãƒˆãƒªãƒƒã‚¯ã‚’è¿”ã™

    def tune(
        self,
        use_ray=False,  # Ray Tuneã‚’ä½¿ç”¨ã™ã‚‹ã‹ã©ã†ã‹ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯False
        iterations=10,  # ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ã®åå¾©å›æ•°ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯10
        *args,  # è¿½åŠ ã®å¼•æ•°
        **kwargs,  # ãã®ä»–ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°
    ):
        """
        Ray Tuneã‚’ä½¿ç”¨ã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ¢ãƒ‡ãƒ«ã®ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ã®2ã¤ã®ãƒ¢ãƒ¼ãƒ‰ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚Ray Tuneã®ä½¿ç”¨ã€ã¾ãŸã¯ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ¡ã‚½ãƒƒãƒ‰ã®ä½¿ç”¨ã§ã™ã€‚
        Ray TuneãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹å ´åˆã€ultralytics.utils.tunerãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã€Œrun_ray_tuneã€é–¢æ•°ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚
        ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€å†…éƒ¨ã®ã€ŒTunerã€ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ã—ã¦ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ã—ã¾ã™ã€‚
        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã€ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã€ãŠã‚ˆã³ã‚«ã‚¹ã‚¿ãƒ å¼•æ•°ã‚’çµ„ã¿åˆã‚ã›ã¦ã€ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ§‹æˆã—ã¾ã™ã€‚

        Args:
            use_ray (bool): Trueã®å ´åˆã€ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ã«Ray Tuneã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯Falseã§ã™ã€‚
            iterations (int): å®Ÿè¡Œã™ã‚‹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ã®åå¾©å›æ•°ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯10ã§ã™ã€‚
            *args (List): è¿½åŠ ã®å¼•æ•°ã®å¯å¤‰é•·å¼•æ•°ãƒªã‚¹ãƒˆã€‚
            **kwargs (Dict): ä»»æ„ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¼•æ•°ã€‚ã“ã‚Œã‚‰ã¯ã€ãƒ¢ãƒ‡ãƒ«ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ãŠã‚ˆã³ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨çµ„ã¿åˆã‚ã•ã‚Œã¾ã™ã€‚

        Returns:
            (Dict): ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¤œç´¢ã®çµæœã‚’å«ã‚€è¾æ›¸ã€‚

        Raises:
            AssertionError: ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ãªã„å ´åˆã€‚

        Examples:
            >>> model = YOLO("yolo11n.pt")
            >>> results = model.tune(use_ray=True, iterations=20)
            >>> print(results)
        """
        self._check_is_pytorch_model()  # ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
        if use_ray:  # Ray Tuneã‚’ä½¿ç”¨ã™ã‚‹å ´åˆ
            from utils.tuner import run_ray_tune  # run_ray_tuneé–¢æ•°ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

            return run_ray_tune(self, max_samples=iterations, *args, **kwargs)  # Ray Tuneã‚’å®Ÿè¡Œ
        else:  # Ray Tuneã‚’ä½¿ç”¨ã—ãªã„å ´åˆ
            from .tuner import Tuner  # Tunerã‚¯ãƒ©ã‚¹ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

            custom = {}  # method defaultsã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°
            args = {**self.overrides, **custom, **kwargs, "mode": "train"}  # highest priority args on the rightã€‚å¼•æ•°ã‚’çµåˆ
            return Tuner(args=args, _callbacks=self.callbacks)(model=self, iterations=iterations)  # Tunerã‚’å®Ÿè¡Œ

    def _apply(self, fn) -> "Model":
        """
        ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¾ãŸã¯ç™»éŒ²ã•ã‚ŒãŸãƒãƒƒãƒ•ã‚¡ã§ã¯ãªã„ãƒ¢ãƒ‡ãƒ«ãƒ†ãƒ³ã‚½ãƒ«ã«é–¢æ•°ã‚’é©ç”¨ã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€predictorã‚’ãƒªã‚»ãƒƒãƒˆã—ã€ãƒ¢ãƒ‡ãƒ«ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã§ãƒ‡ãƒã‚¤ã‚¹ã‚’æ›´æ–°ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€è¦ªã‚¯ãƒ©ã‚¹ã®_applyãƒ¡ã‚½ãƒƒãƒ‰ã®æ©Ÿèƒ½ã‚’æ‹¡å¼µã—ã¾ã™ã€‚
        é€šå¸¸ã€ãƒ¢ãƒ‡ãƒ«ã‚’åˆ¥ã®ãƒ‡ãƒã‚¤ã‚¹ã«ç§»å‹•ã—ãŸã‚Šã€ãã®ç²¾åº¦ã‚’å¤‰æ›´ã—ãŸã‚Šã™ã‚‹ãªã©ã®æ“ä½œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

        Args:
            fn (Callable): ãƒ¢ãƒ‡ãƒ«ã®ãƒ†ãƒ³ã‚½ãƒ«ã«é©ç”¨ã•ã‚Œã‚‹é–¢æ•°ã€‚ã“ã‚Œã¯é€šå¸¸ã€to()ã€cpu()ã€cuda()ã€half()ã€float()ãªã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚

        Returns:
            (Model): é–¢æ•°ãŒé©ç”¨ã•ã‚Œã€å±æ€§ãŒæ›´æ–°ã•ã‚ŒãŸãƒ¢ãƒ‡ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€‚

        Raises:
            AssertionError: ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ãªã„å ´åˆã€‚

        Examples:
            >>> model = Model("yolo11n.pt")
            >>> model = model._apply(lambda t: t.cuda())  # ãƒ¢ãƒ‡ãƒ«ã‚’GPUã«ç§»å‹•
        """
        self._check_is_pytorch_model()  # ãƒ¢ãƒ‡ãƒ«ãŒPyTorchãƒ¢ãƒ‡ãƒ«ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
        self = super()._apply(fn)  # noqa
        self.predictor = None  # ãƒ‡ãƒã‚¤ã‚¹ãŒå¤‰æ›´ã•ã‚ŒãŸå¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€predictorã‚’ãƒªã‚»ãƒƒãƒˆ
        self.overrides["device"] = self.device  # self.deviceã®æ–‡å­—åˆ—è¡¨ç¾(ä¾‹: device(type='cuda', index=0)) -> 'cuda:0'
        return self  # æ›´æ–°ã•ã‚ŒãŸãƒ¢ãƒ‡ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™

    @property
    def names(self) -> list:
        """
        ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ¢ãƒ‡ãƒ«ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸã‚¯ãƒ©ã‚¹åã‚’å–å¾—ã—ã¾ã™ã€‚

        ã“ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ã€ãƒ¢ãƒ‡ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¯ãƒ©ã‚¹åã‚’è¿”ã—ã¾ã™ã€‚
        ultralytics.nn.autobackendãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã€Œcheck_class_namesã€é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã€ã‚¯ãƒ©ã‚¹åã®æœ‰åŠ¹æ€§ã‚’ç¢ºèªã—ã¾ã™ã€‚
        predictorãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€åå‰ã‚’å–å¾—ã™ã‚‹å‰ã«ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã¾ã™ã€‚

        Returns:
            (Dict[int, str]): ãƒ¢ãƒ‡ãƒ«ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸã‚¯ãƒ©ã‚¹åã®dictã€‚

        Raises:
            AttributeError: ãƒ¢ãƒ‡ãƒ«ã¾ãŸã¯predictorã«ã€Œnamesã€å±æ€§ãŒãªã„å ´åˆã€‚

        Examples:
            >>> model = YOLO("yolo11n.pt")
            >>> print(model.names)
            {0: 'person', 1: 'bicycle', 2: 'car', ...}
        """
        from nn.autobackend import check_class_names  # check_class_namesé–¢æ•°ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

        if hasattr(self.model, "names"):  # ãƒ¢ãƒ‡ãƒ«ã«nameså±æ€§ãŒã‚ã‚‹å ´åˆ
            return check_class_names(self.model.names)  # ã‚¯ãƒ©ã‚¹åã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦è¿”ã™
        if not self.predictor:  # ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå½¢å¼ã§ã¯ã€predict()ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¾ã§predictorãŒå®šç¾©ã•ã‚Œã¾ã›ã‚“
            self.predictor = self._smart_load("predictor")(overrides=self.overrides, _callbacks=self.callbacks)  # predictorã‚’ãƒ­ãƒ¼ãƒ‰
            self.predictor.setup_model(model=self.model, verbose=False)  # predictorã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        return self.predictor.model.names  # predictorã‹ã‚‰ã‚¯ãƒ©ã‚¹åã‚’è¿”ã™

    @property
    def device(self) -> torch.device:
        """
        ãƒ¢ãƒ‡ãƒ«ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã„ã‚‹ãƒ‡ãƒã‚¤ã‚¹ã‚’å–å¾—ã—ã¾ã™ã€‚

        ã“ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ã€ãƒ¢ãƒ‡ãƒ«ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒç¾åœ¨æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒã‚¤ã‚¹ï¼ˆCPUã¾ãŸã¯GPUï¼‰ã‚’æ±ºå®šã—ã¾ã™ã€‚
        ã“ã‚Œã¯ã€nn.Moduleã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹ãƒ¢ãƒ‡ãƒ«ã«ã®ã¿é©ç”¨ã•ã‚Œã¾ã™ã€‚

        Returns:
            (torch.device): ãƒ¢ãƒ‡ãƒ«ã®ãƒ‡ãƒã‚¤ã‚¹ï¼ˆCPU / GPUï¼‰ã€‚

        Raises:
            AttributeError: ãƒ¢ãƒ‡ãƒ«ãŒPyTorch nn.Moduleã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ãªã„å ´åˆã€‚

        Examples:
            >>> model = YOLO("yolo11n.pt")
            >>> print(model.device)
            device(type='cuda', index=0)  # CUDAãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ
            >>> model = model.to("cpu")
            >>> print(model.device)
            device(type='cpu')
        """
        return next(self.model.parameters()).device if isinstance(self.model, nn.Module) else None  # ãƒ¢ãƒ‡ãƒ«ã®ãƒ‡ãƒã‚¤ã‚¹ã‚’è¿”ã™

    @property
    def transforms(self):
        """
        ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ¢ãƒ‡ãƒ«ã®å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã«é©ç”¨ã•ã‚Œã‚‹å¤‰æ›ã‚’å–å¾—ã—ã¾ã™ã€‚

        ã“ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ã€ãƒ¢ãƒ‡ãƒ«ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯å¤‰æ›ã‚’è¿”ã—ã¾ã™ã€‚
        å¤‰æ›ã«ã¯é€šå¸¸ã€ãƒ¢ãƒ‡ãƒ«ã«å…¥åŠ›ã•ã‚Œã‚‹å‰ã«å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã«é©ç”¨ã•ã‚Œã‚‹ã€ã‚µã‚¤ã‚ºå¤‰æ›´ã€æ­£è¦åŒ–ã€ãƒ‡ãƒ¼ã‚¿æ‹¡å¼µãªã©ã®å‰å‡¦ç†ã‚¹ãƒ†ãƒƒãƒ—ãŒå«ã¾ã‚Œã¾ã™ã€‚

        Returns:
            (object | None): ãƒ¢ãƒ‡ãƒ«ã§ä½¿ç”¨å¯èƒ½ãªå ´åˆã¯å¤‰æ›ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ãã‚Œä»¥å¤–ã®å ´åˆã¯Noneã€‚

        Examples:
            >>> model = YOLO("yolo11n.pt")
            >>> transforms = model.transforms
            >>> if transforms:
            ...     print(f"Model transforms: {transforms}")
            ... else:
            ...     print("No transforms defined for this model.")
        """
        return self.model.transforms if hasattr(self.model, "transforms") else None  # ãƒ¢ãƒ‡ãƒ«ã®å¤‰æ›ã‚’è¿”ã™

    def add_callback(self, event: str, func) -> None:
        """
        æŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ™ãƒ³ãƒˆã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’è¿½åŠ ã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚„æ¨è«–ãªã©ã®ãƒ¢ãƒ‡ãƒ«æ“ä½œä¸­ã«ç‰¹å®šã®ã‚¤ãƒ™ãƒ³ãƒˆã§ãƒˆãƒªã‚¬ãƒ¼ã•ã‚Œã‚‹ã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’ç™»éŒ²ã§ãã¾ã™ã€‚
        ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ã€ãƒ¢ãƒ‡ãƒ«ã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã®ã•ã¾ã–ã¾ãªæ®µéšã§ãƒ¢ãƒ‡ãƒ«ã®å‹•ä½œã‚’æ‹¡å¼µãŠã‚ˆã³ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹æ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚

        Args:
            event (str): ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ã‚¢ã‚¿ãƒƒãƒã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã®åå‰ã€‚Ultralyticsãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§èªè­˜ã•ã‚Œã‚‹æœ‰åŠ¹ãªã‚¤ãƒ™ãƒ³ãƒˆåã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
            func (Callable): ç™»éŒ²ã™ã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã€‚ã“ã®é–¢æ•°ã¯ã€æŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç”Ÿã—ãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚

        Raises:
            ValueError: ã‚¤ãƒ™ãƒ³ãƒˆåãŒèªè­˜ã•ã‚Œãªã„ã‹ã€ç„¡åŠ¹ãªå ´åˆã€‚

        Examples:
            >>> def on_train_start(trainer):
            ...     print("ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãŒé–‹å§‹ã•ã‚Œã¾ã™ï¼")
            >>> model = YOLO("yolo11n.pt")
            >>> model.add_callback("on_train_start", on_train_start)
            >>> model.train(data="coco8.yaml", epochs=1)
        """
        self.callbacks[event].append(func)  # ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’è¿½åŠ 

    def clear_callback(self, event: str) -> None:
        """
        æŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ™ãƒ³ãƒˆã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ™ãƒ³ãƒˆã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ã‚«ã‚¹ã‚¿ãƒ ãŠã‚ˆã³ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’å‰Šé™¤ã—ã¾ã™ã€‚
        æŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ™ãƒ³ãƒˆã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ç©ºã®ãƒªã‚¹ãƒˆã«ãƒªã‚»ãƒƒãƒˆã—ã€ãã®ã‚¤ãƒ™ãƒ³ãƒˆã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’åŠ¹æœçš„ã«å‰Šé™¤ã—ã¾ã™ã€‚

        Args:
            event (str): ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã®åå‰ã€‚ã“ã‚Œã¯ã€Ultralyticsã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ã§èªè­˜ã•ã‚Œã‚‹æœ‰åŠ¹ãªã‚¤ãƒ™ãƒ³ãƒˆåã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

        Examples:
            >>> model = YOLO("yolo11n.pt")
            >>> model.add_callback("on_train_start", lambda: print("ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸ"))
            >>> model.clear_callback("on_train_start")
            >>> # 'on_train_start'ã®ã™ã¹ã¦ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸ

        Notes:
            - ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¿½åŠ ã—ãŸã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã€Ultralyticsãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã«ã‚ˆã£ã¦æä¾›ã•ã‚Œã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®ä¸¡æ–¹ã«å½±éŸ¿ã—ã¾ã™ã€‚
            - ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ãŸå¾Œã€æ–°ã—ã„ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒè¿½åŠ ã•ã‚Œã‚‹ã¾ã§ã€æŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ™ãƒ³ãƒˆã«å¯¾ã—ã¦ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ã€‚
            - ç‰¹å®šã®æ“ä½œã®é©åˆ‡ãªæ©Ÿèƒ½ã«å¿…è¦ãªã€é‡è¦ãªã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å«ã‚ã€ã™ã¹ã¦ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å‰Šé™¤ã™ã‚‹ãŸã‚ã€æ³¨æ„ã—ã¦ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚
        """
        self.callbacks[event] = []  # ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢

    def reset_callbacks(self) -> None:
        """
        ã™ã¹ã¦ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé–¢æ•°ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã™ã¹ã¦ã®ã‚¤ãƒ™ãƒ³ãƒˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’å¾©å…ƒã—ã€ä»¥å‰ã«è¿½åŠ ã•ã‚ŒãŸã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å‰Šé™¤ã—ã¾ã™ã€‚
        ã™ã¹ã¦ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’åå¾©å‡¦ç†ã—ã€ç¾åœ¨ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã«ç½®ãæ›ãˆã¾ã™ã€‚

        ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ã€ã€Œcallbacks.default_callbacksã€è¾æ›¸ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã¯ã€on_train_startã€on_epoch_endãªã©ã€ãƒ¢ãƒ‡ãƒ«ã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã®ã•ã¾ã–ã¾ãªã‚¤ãƒ™ãƒ³ãƒˆã«å¯¾ã™ã‚‹å®šç¾©æ¸ˆã¿ã®é–¢æ•°ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚«ã‚¹ã‚¿ãƒ å¤‰æ›´ã‚’åŠ ãˆãŸå¾Œã§å…ƒã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚»ãƒƒãƒˆã«æˆ»ã—ã€ç•°ãªã‚‹å®Ÿè¡Œã¾ãŸã¯å®Ÿé¨“é–“ã§ä¸€è²«ã—ãŸå‹•ä½œã‚’ç¢ºä¿ã™ã‚‹å ´åˆã«å½¹ç«‹ã¡ã¾ã™ã€‚

        Examples:
            >>> model = YOLO("yolo11n.pt")
            >>> model.add_callback("on_train_start", custom_function)
            >>> model.reset_callbacks()
            # ã™ã¹ã¦ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé–¢æ•°ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã—ãŸ
        """
        for event in callbacks.default_callbacks.keys():  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’åå¾©å‡¦ç†
            self.callbacks[event] = [callbacks.default_callbacks[event][0]]  # ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãƒªã‚»ãƒƒãƒˆ

    @staticmethod
    def _reset_ckpt_args(args: dict) -> dict:
        """
        PyTorchãƒ¢ãƒ‡ãƒ«ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã¨ãã«ã€ç‰¹å®šã®å¼•æ•°ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚

        ã“ã®é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å…¥åŠ›å¼•æ•°ã®è¾æ›¸ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ã¦ã€ãƒ¢ãƒ‡ãƒ«ã®ãƒ­ãƒ¼ãƒ‰ã«é‡è¦ã¨è¦‹ãªã•ã‚Œã‚‹ç‰¹å®šã®ã‚­ãƒ¼ã®ã‚»ãƒƒãƒˆã®ã¿ã‚’ä¿æŒã—ã¾ã™ã€‚
        ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã¨ãã«ã€é–¢é€£ã™ã‚‹å¼•æ•°ã®ã¿ãŒä¿æŒã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
        ä¸è¦ãªã€ã¾ãŸã¯æ½œåœ¨çš„ã«ç«¶åˆã™ã‚‹è¨­å®šã¯ç ´æ£„ã—ã¾ã™ã€‚

        Args:
            args (dict): ã•ã¾ã–ã¾ãªãƒ¢ãƒ‡ãƒ«å¼•æ•°ã¨è¨­å®šã‚’å«ã‚€è¾æ›¸ã€‚

        Returns:
            (dict): å…¥åŠ›å¼•æ•°ã‹ã‚‰æŒ‡å®šã•ã‚ŒãŸincludeã‚­ãƒ¼ã®ã¿ã‚’å«ã‚€æ–°ã—ã„è¾æ›¸ã€‚

        Examples:
            >>> original_args = {"imgsz": 640, "data": "coco.yaml", "task": "detect", "batch": 16, "epochs": 100}
            >>> reset_args = Model._reset_ckpt_args(original_args)
            >>> print(reset_args)
            {'imgsz': 640, 'data': 'coco.yaml', 'task': 'detect'}
        """
        include = {"imgsz", "data", "task", "single_cls"}  # PyTorchãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã¨ãã«ã€ã“ã‚Œã‚‰ã®å¼•æ•°ã®ã¿ã‚’è¨˜æ†¶ã—ã¾ã™
        return {k: v for k, v in args.items() if k in include}  # æŒ‡å®šã•ã‚ŒãŸã‚­ãƒ¼ã®ã¿ã‚’å«ã‚€è¾æ›¸ã‚’è¿”ã™

    # def __getattr__(self, attr):
    #    """Raises error if object has no requested attribute."""
    #    name = self.__class__.__name__
    #    raise AttributeError(f"'{name}' object has no attribute '{attr}'. See valid attributes below.\n{self.__doc__}")

    def _smart_load(self, key: str):
        """
        ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¹ã‚¯ã«åŸºã¥ã„ã¦é©åˆ‡ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚

        ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãƒ¢ãƒ‡ãƒ«ã®ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ã¨æŒ‡å®šã•ã‚ŒãŸã‚­ãƒ¼ã«åŸºã¥ã„ã¦ã€é©åˆ‡ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆãƒ¢ãƒ‡ãƒ«ã€ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼ã€ãƒãƒªãƒ‡ãƒ¼ã‚¿ãƒ¼ã€ã¾ãŸã¯äºˆæ¸¬å­ï¼‰ã‚’å‹•çš„ã«é¸æŠã—ã¦è¿”ã—ã¾ã™ã€‚
        task_mapå±æ€§ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ­ãƒ¼ãƒ‰ã™ã‚‹æ­£ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ±ºå®šã—ã¾ã™ã€‚

        Args:
            key (str): ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¿ã‚¤ãƒ—ã€‚ ã€Œmodelã€ã€ã€Œtrainerã€ã€ã€Œvalidatorã€ã€ã€Œpredictorã€ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

        Returns:
            (object): æŒ‡å®šã•ã‚ŒãŸã‚­ãƒ¼ã¨ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ã«å¯¾å¿œã™ã‚‹ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã€‚

        Raises:
            NotImplementedError: æŒ‡å®šã•ã‚ŒãŸã‚­ãƒ¼ãŒç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆã€‚

        Examples:
            >>> model = Model(task="detect")
            >>> predictor = model._smart_load("predictor")
            >>> trainer = model._smart_load("trainer")

        Notes:
            - ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯é€šå¸¸ã€Modelã‚¯ãƒ©ã‚¹ã®ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦å†…éƒ¨çš„ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
            - task_mapå±æ€§ã¯ã€å„ã‚¿ã‚¹ã‚¯ã«å¯¾ã—ã¦æ­£ã—ã„ãƒãƒƒãƒ”ãƒ³ã‚°ã§é©åˆ‡ã«åˆæœŸåŒ–ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
        """
        try:
            return self.task_map[self.task][key]  # ã‚¿ã‚¹ã‚¯ãƒãƒƒãƒ—ã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰
        except Exception as e:  # ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆ
            name = self.__class__.__name__  # ã‚¯ãƒ©ã‚¹åã‚’å–å¾—
            mode = inspect.stack()[1][3]  # é–¢æ•°åã‚’å–å¾—
            raise NotImplementedError(
                emojis(f"WARNING âš ï¸ '{name}'ãƒ¢ãƒ‡ãƒ«ã¯ã€'{self.task}'ã‚¿ã‚¹ã‚¯ã«å¯¾ã—ã¦'{mode}'ãƒ¢ãƒ¼ãƒ‰ã‚’ã¾ã ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚")
            ) from e  # NotImplementedErrorã‚’ç™ºç”Ÿ

    @property
    def task_map(self) -> dict:
        """
        ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¹ã‚¯ã‹ã‚‰ã•ã¾ã–ã¾ãªãƒ¢ãƒ¼ãƒ‰ã«å¯¾å¿œã™ã‚‹ã‚¯ãƒ©ã‚¹ã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’æä¾›ã—ã¾ã™ã€‚

        ã“ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹å„ã‚¿ã‚¹ã‚¯ï¼ˆä¾‹ï¼šæ¤œå‡ºã€ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã€åˆ†é¡ï¼‰ã‚’ãƒã‚¹ãƒˆã•ã‚ŒãŸè¾æ›¸ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹è¾æ›¸ã‚’è¿”ã—ã¾ã™ã€‚
        ãƒã‚¹ãƒˆã•ã‚ŒãŸè¾æ›¸ã«ã¯ã€ç•°ãªã‚‹æ“ä½œãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ¢ãƒ‡ãƒ«ã€ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼ã€ãƒãƒªãƒ‡ãƒ¼ã‚¿ãƒ¼ã€äºˆæ¸¬å­ï¼‰ã‹ã‚‰ãã‚Œãã‚Œã®ã‚¯ãƒ©ã‚¹å®Ÿè£…ã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚

        ã“ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã«ã‚ˆã‚Šã€ãƒ¢ãƒ‡ãƒ«ã®ã‚¿ã‚¹ã‚¯ã¨ç›®çš„ã®æ“ä½œãƒ¢ãƒ¼ãƒ‰ã«åŸºã¥ã„ã¦é©åˆ‡ãªã‚¯ãƒ©ã‚¹ã‚’å‹•çš„ã«ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã™ã€‚
        ã“ã‚Œã«ã‚ˆã‚Šã€Ultralyticsãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯å†…ã®ã•ã¾ã–ã¾ãªã‚¿ã‚¹ã‚¯ã¨ãƒ¢ãƒ¼ãƒ‰ã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã®æŸ”è»Ÿã§æ‹¡å¼µå¯èƒ½ãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãŒå®¹æ˜“ã«ãªã‚Šã¾ã™ã€‚

        Returns:
            (Dict[str, Dict[str, Any]]): ã‚­ãƒ¼ãŒã‚¿ã‚¹ã‚¯åï¼ˆstrï¼‰ã§ã€å€¤ãŒãƒã‚¹ãƒˆã•ã‚ŒãŸè¾æ›¸ã§ã‚ã‚‹è¾æ›¸ã€‚
            å„ãƒã‚¹ãƒˆã•ã‚ŒãŸè¾æ›¸ã«ã¯ã€ã€Œmodelã€ã€ã€Œtrainerã€ã€ã€Œvalidatorã€ã€ãŠã‚ˆã³ã€Œpredictorã€ã¨ã„ã†ã‚­ãƒ¼ãŒã‚ã‚Šã€ãã‚Œãã‚Œã®ã‚¯ãƒ©ã‚¹å®Ÿè£…ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã•ã‚Œã¾ã™ã€‚

        Examples:
            >>> model = Model()
            >>> task_map = model.task_map
            >>> detect_class_map = task_map["detect"]
            >>> segment_class_map = task_map["segment"]

        Note:
            ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿéš›ã®å®Ÿè£…ã¯ã€Ultralyticsãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ç‰¹å®šã®ã‚¿ã‚¹ã‚¯ã¨ã‚¯ãƒ©ã‚¹ã«ã‚ˆã£ã¦ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚
            ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ–‡å­—åˆ—ã¯ã€äºˆæƒ³ã•ã‚Œã‚‹å‹•ä½œã¨æ§‹é€ ã®ä¸€èˆ¬çš„ãªèª¬æ˜ã‚’æä¾›ã—ã¾ã™ã€‚
        """
        raise NotImplementedError("ãƒ¢ãƒ‡ãƒ«ã®ã‚¿ã‚¹ã‚¯ãƒãƒƒãƒ—ã‚’æä¾›ã—ã¦ãã ã•ã„!")  # task_mapãŒå®Ÿè£…ã•ã‚Œã¦ã„ãªã„å ´åˆã€NotImplementedErrorã‚’ç™ºç”Ÿ